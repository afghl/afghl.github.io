---
layout: post
title:  "一致性哈希（Consistent Hashing）原理以及C语言实现"
date:   2016-07-04 15:37:00 +0800
---

看一些分布式相关的技术文章或书籍时，经常看到一个词--一致性哈希。对于这个技术一直似懂非懂。今天花了半天的时间好好研究了它的原理和实现，发现一点都不复杂。于是写篇文章分享一下，并用C语言实现一个简单的demo。

本文需要的基础知识：

1. 数据结构基础知识，特别是普通的Hash实现相关的知识。
2. 能读懂C语言。

下面，我们就从基本的Hash算法说起。

### 负载均衡与Hash算法

分布式系统中（如：web存储），当服务增长到一定规模时，惯常的做法是集群化，引入负载均衡，这样做的好处是：1. 高可用。2. 解耦。从外部看，透明化了集群的内部细节（外部都通过负载均衡服务器通信，然后由负载均衡服务器分发请求）。

假设一个简单的场景：有4个cache服务器（后简称cache）组成的集群，当一个对象object传入集群时，这个对象应该存储在哪一个cache里呢？一种简单的方法是使用映射公式：

~~~
Hash(object) % 4
~~~

这个算法就可以保证任何object都会尽可能随机落在其中一个cache中。一切运行正常。

然后考虑以下情况：

- 由于流量增大，需要增加一台cache，共5个cache。这时，映射公式就变成`Hash(object) % 5`。
- 有一个cache服务器down掉，变成3个cache。这时，映射公式就变成`Hash(object) % 3`。

**可见，无论新增还是减少结点，改变映射公式，而由于映射公式改变，几乎所有的object都会被映射到新的cache中，这意味着一时间所有的缓存全部失效。** 大量的数据请求落在app层甚至是db层上，这对服务器的影响当然是灾难性的。

这时，我们就需要新的算法。

### 一致性Hash

一致性hash的出现就是为了解决这个问题：**当结点数量改变时，能够尽可能小的改变已存在的映射关系，使失效的缓存数量可能小。**

一致性Hash的基本思想就是分两步走：

1. 把object求hash（这一步和之前相同）；
2. **把cache也求hash，然后把object和cache的hash值放入一个hash空间，通过一定的规则决定object落在哪一个cache中。**

下面，会逐步说明它的实现。

#### 成环

考虑通常的Hash算法都是将value映射到一个32位的key值，也即是0~2^32-1次方的数值空间；我们可以将这个空间想象成一个首（ 0 ）尾（ 2^32-1 ）相接的圆环，如下图所示。
