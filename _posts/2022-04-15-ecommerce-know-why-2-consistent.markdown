---
title: "电商业务架构背后的Know-Why：关于一致性的思考和Best Practise"
date: 2022-04-15 15:20:00 +0800
tags: [pattern, ecommerce, architecture, consistency]
---

## 各种一致性模型和选型决策树

## 处理不一致

## 状态机+幂等，如何解决大部分的问题

大部分场景下，通过正确设计的状态机和接口幂等的方法，是解决大部分问题（一致性，状态回滚、甚至资损）的底座。以支付域的订单设计聊聊我的理解。

### 支付订单的设计，和背后的原理

电商的支付域，依赖第三方支付公司的能力，完成资金流的转移。针对这种第三方支付的场景，一个最简化的状态机可以是这样设计的：

![Alt](/images/pay_order_status.jpg)

电商支付域需要调用第三方接口，并通过反查/通知的方式获得结果。所以整个状态机抽象为：Init → Processing → Success / Fail。如果你仔细观察，这里其实是**一个关于调用异步接口的通用设计**。有了健壮的状态机设计后，我们只需要关注哪些动作/接口能推进状态机，这个接口本身是否幂等即可；同时，一个状态机**总是应该流转到终态**，可以建立补偿任务来推进未完结的状态机，其实就是保证的系统的最终一致，主要上下游保证也幂等，那么可以放心的重试。

下面说说状态机如何设计。

### 状态机的通用设计

1. 每个状态应当的不可逆

这是**非常关键**的设计。以上面的支付状态为例，只要支付状态是支付成功，就不允许再更新为 Processing 状态，否则就是资损风险（重复支付）。可以理解为游戏通关的一个保存点：当通关了一个关卡，就不能重玩了。

2. 保守推进

什么时候能推进，应该是有严格定义的，以支付域为例，有以下原则：

**保守严格定义什么是”支付成功“**。这里要有明确的约定支付成功的协议，非这个协议的 Response，都不能推进到 Success。否则：卖家资损。
**保守严格定义什么是”支付失败“**。在支付的场景里，整个支付过程是需要用户操作，所以只要用户不输入，就不能认为是失败。否则：买家资损。 1. 在支付场景里，没有严格的可以认定为失败的场景，最后只能用**超时**：超过一定时间未支付，就是失败。
**RPC 失败应该怎么处理？**不能对错误有任何认定。所有的 RPC 错误都不应该推进状态机。

3. 状态推进接口保证幂等

这个很好理解。

### 再次说说幂等

用比较直观的语言说，幂等的定义是：同一个指令，执行多次的效果和执行一次是一样的。在上面状态机推进的例子中，幂等的实现是状态机本身保证的：在接收到指令 cmd 后，判断当前状态是否这个指令的前缀状态，能否处理这个状态。如果可以，则推进状态机：

```go
if payOrder.Status == Processing {
    payOrder.Accept(paySuccessCmd)
}
```

幂等更通用的实现是两步：

1. 定义什么是“同一个指令”，给这个指令一个唯一标识。
2. 在接口实现中，记录并判断指令的执行情况：如果这个指令已经执行，下次就直接跳过。

有时候，幂等的实现会更复杂，这个复杂度往往在于**究竟如何定义“同一个指令”**。比如这样的场景：用户在下单页生成订单，我们用唯一的订单号来标识并处理接口幂等，这个订单号如何生成呢？有几种选择：

1. 在后端接口创建订单时生成：这样如果上游重试，会导致重复订单。
2. 在前端点击下单按钮时生成：这样有可能因为网络抖动，而发生重复生成。
3. 在渲染下单页时就已经生成，这样无论何时点击，都保证了幂等，不会发生重复订单的情况。

显然，3 是更好的方法。可见，幂等应该是端到端的，也就是“同一个指令”应该由指令的发起方定义：只有用户能定义这是同一次下单，而这个唯一标识，应该透传到事务执行的最底层。

## Ref

- 《@Software Architecture: The Hard Parts》
