---
title:  "Golang学习（1） - Go并发模式"
date:   2021-04-18 15:13:00 +0800
tags: [go,golang,concurrent,pattern,goroutine,channel]
---

最近工作用到Golang会比较多。因此计划花2 - 3星期学学Go语言。在这里记录学习过程的一些记录和想法。希望对你也有帮助。

要快速一个新的语言，我认为有几个重点需要关注：1. 知道它的关键部分的设计思想和原理，避免踩坑，而且能快速定位和解决问题；2. 知道它的设计哲学，写出比较好的代码。

基于此，我认为有几个比较重要的部分值得学习整理：

- 并发的设计和使用
- 运行时
- 设计哲学
- 工程化

这一篇先来说说go concurrent pattern，它是go语言的最大亮点和最值得学习的地方。

浏览了一些书和网上的一些课程，基本都没有知识结构。所以只能类比之前的经验（java）先理一下我的疑问，再来逐个解答，以问题的方式串起来这一块知识，我们大概可以这样提问：

- 协程是啥？和它的一些特点：用户态调度，非抢占式，轻量级线程等。
- go是怎么实现协程的：调度器的实现原理，goroutine。
- 用户态的调度器怎么实现这些功能，例如协程的yield，等等。
- goroutine的状态，生命周期以及观测的方法。
- go的并发pattern：channel。
- channel是什么和它的理论？（计算机并发一般来说早已有各种理论支撑，语言工具包甚至关键字都是对理论的实现）
- go对channel的实现，具体的数据结构。
- 为什么有很多并发场景可以转换成用channel这个思想去解决。
- 用channel的优势是啥，原有的程序怎么改造（abc线程交替打印）

可见goroutine和channel是比较重要的两块，我们先从协程说起。

### 协程coroutine

golang使用协程而非线程进行并发。操作系统层面有三个“执行体”的概念：进程，线程，协程。这些概念的诞生都是为了解决一个问题：CPU计算速度远远高于CPU访问内存、磁盘、网络的速度。进程和线程的设计就是为了让CPU可以同一时间做多件事情。而对每个执行体而言，它认为CPU只为自己服务。

进程和线程的区别大家都知道：两个进程之间，内存隔离，通信一般只能靠socket；而多线程在同一个进程里，使用同一个内存空间。协程也是一个执行体，它可以理解为用户态的线程，在使用上和线程基本无异，主要有几个不同：

1. 协程轻量级：所占用的空间更小，协程切换的开销更小
2. 线程的调度发生在操作系统，由操作系统实现；而协程的调度发生在用户内存空间，由用户实现。

既然协程的用法和线程很像，那么为什么需要用协程取代线程呢？其中一个原因，不难想到，就是高负载的网络请求模型这个典型场景。对网络服务器来说，大量的来自客户端的请求包和服务器的返回包，都是网络 IO；在响应请求的过程中，往往需要访问存储来保存和读取自身的状态，这也涉及本地或网络 IO，也就是说要保持足够的吞吐量，必须创建足够多的线程，而实际上线程也经常是瓶颈。

一个线程所需的内存空间大概是数MB（linux），也就是1000个线程已经是GB级别。在java里，我们的解法是使用线程池去管理这种资源：在服务器节点有一个worker pool，它去处理请求，如果这批线程全都忙碌（其实都在等IO或者等锁），就拒绝请求。这也就是为什么，一个典型的IO密集型应用即使在大流量冲击时，CPU使用率一般也远远不会打满，而这时有大量的线程阻塞等待，线程就成为了资源瓶颈。我们可以看到很多线上事故，最初暴露的现象往往是服务器节点报错“无可用线程”。

协程通过降低空间成本（内存空间）和时间成本（降低调度的时间）来解决这个问题。何以可能呢？

### goroutine与调度



### channel

### ref
- 《Concurrency in Go》
- https://time.geekbang.org/column/article/304188
- https://time.geekbang.org/dailylesson/detail/100056885
- https://www.youtube.com/watch?v=f6kdp27TYZs
- https://www.youtube.com/watch?v=QDDwwePbDtw
- https://blog.cloudflare.com/how-stacks-are-handled-in-go/
